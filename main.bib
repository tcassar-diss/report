@article{10.1145/3214304,
    author = {Liu, Ming and Xue, Zhi and Xu, Xianghua and Zhong, Changmin and
              Chen, Jinjun},
    title = {Host-Based Intrusion Detection System with System Calls: Review and
             Future Trends},
    year = {2018},
    issue_date = {September 2019},
    publisher = {Association for Computing Machinery},
    address = {New York, NY, USA},
    volume = {51},
    number = {5},
    issn = {0360-0300},
    url = {https://doi.org/10.1145/3214304},
    doi = {10.1145/3214304},
    abstract = {In a contemporary data center, Linux applications often generate
                a large quantity of real-time system call traces, which are not
                suitable for traditional host-based intrusion detection systems
                deployed on every single host. Training data mining models with
                system calls on a single host that has static computing and
                storage capacity is time-consuming, and intermediate datasets are
                not capable of being efficiently handled. It is cumbersome for
                the maintenance and updating of host-based intrusion detection
                systems (HIDS) installed on every physical or virtual host, and
                comprehensive system call analysis can hardly be performed to
                detect complex and distributed attacks among multiple hosts.
                Considering these limitations of current system-call-based HIDS,
                in this article, we provide a review of the development of
                system-call-based HIDS and future research trends. Algorithms and
                techniques relevant to system-call-based HIDS are investigated,
                including feature extraction methods and various data mining
                algorithms. The HIDS dataset issues are discussed, including
                currently available datasets with system calls and approaches for
                researchers to generate new datasets. The application of
                system-call-based HIDS on current embedded systems is studied,
                and related works are investigated. Finally, future research
                trends are forecast regarding three aspects, namely, the
                reduction of the false-positive rate, the improvement of
                detection efficiency, and the enhancement of collaborative
                security.},
    journal = {ACM Comput. Surv.},
    month = nov,
    articleno = {98},
    numpages = {36},
    keywords = {Cybersecurity, big data, cloud computing, intrusion detection,
                system call},
}

@misc{rustbook_unsafe,
    author = {{The Rust Project Developers}},
    title = {The Rust Programming Language: Unsafe Rust},
    year = { 2025 },
    url = {https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html},
    note = {Accessed: 2025-03-31},
}

@inproceedings{SOK,
    title = {SoK: Software Compartmentalization},
    author = {Lefeuvre, Hugo and Dautenhahn, Nathan and Chisnall, David and
              Olivier, Pierre},
    booktitle = {46th IEEE Symposium on Security and Privacy (S\&P'25)},
    year = {2024},
}

@inproceedings{ANDROID_SOK,
    author = {Acar, Yasemin and Backes, Michael and Bugiel, Sven and Fahl,
              Sascha and McDaniel, Patrick and Smith, Matthew},
    booktitle = {Proceedings of the 2016 IEEE Symposium on Security and Privacy},
    title = {{SoK}: Lessons Learned from {Android} Security Research for
             Appified Software Platforms},
    year = {2016},
    series = {S\&P'16},
    doi = {10.1109/SP.2016.33},
    file = {:papers/Acar2016.pdf:PDF},
    groups = {SoKs, Isolation},
}

@inproceedings{PRIVMAN,
    author = {Kilpatrick, Douglas},
    booktitle = {Proc. of the 2003 {USENIX} Annual Technical Conference},
    title = {Privman: A Library for Partitioning Applications.},
    series = {ATC'03},
    file = {:papers/Kilpatrick2003.pdf:PDF},
    groups = {App Isolation, Isolation},
}

@incollection{CONFFUZZ,
    title = {Assessing the Impact of Interface Vulnerabilities in
             Compartmentalized Software},
    author = {Lefeuvre, Hugo and B{\u{a}}doiu, Vlad-Andrei and Chien, Yi and
              Huici, Felipe and Dautenhahn, Nathan and Olivier, Pierre},
    booktitle = {Proceedings of 30th Network and Distributed System Security
                 (NDSS'23)},
    year = {2022},
    publisher = {Internet Society},
}

@inproceedings{MPK,
    title = {libmpk: Software abstraction for intel memory protection keys
             (intel MPK)},
    author = {Park, Soyeon and Lee, Sangho and Xu, Wen and Moon, Hyungon and Kim
              , Taesoo},
    booktitle = {2019 USENIX Annual Technical Conference (USENIX ATC 19)},
    pages = {241--254},
    year = {2019},
}


@book{UNDERSTANDING_LINUX_KERNEL,
    title = {Understanding the Linux Kernel},
    author = {Bovet, Daniel P. and Cesati, Marco},
    year = {2005},
    publisher = {O'Reilly Media},
    edition = {3rd},
    isbn = {9780596005658},
}

@online{LEARNING_EBPF,
    author = {Liz Rice},
    title = {Learning eBPF: Programming the Linux Kernel for Observability,
             Security, and Networking},
    year = {2023},
    publisher = {O'Reilly Media},
    url = {
           https://learning.oreilly.com/library/view/learning-ebpf/9781098135119/ch01.html#ebpfapostrophes_roots_the_berkeley_pack
           },
    note = {Accessed via O'Reilly Online Learning},
}

@inproceedings{SIDECAR,
    title = {Design patterns for container-based distributed systems},
    author = {Burns, Brendan and Oppenheimer, David},
    booktitle = {8th USENIX Workshop on Hot Topics in Cloud Computing (HotCloud
                 16)},
    year = {2016},
}


@misc{bpf_kfuncs_docs,
    author = {{The Linux Kernel Developers}},
    title = {BPF Kernel Functions (kfuncs) - The Linux Kernel Documentation},
    year = 2025,
    url = {https://docs.kernel.org/bpf/kfuncs.html},
    note = {Accessed: 2025-03-31},
}


@misc{BPF_PACKET_MITIGATION,
    author = {{Tigera, Inc.}},
    title = {{eBPF and XDP Explained}},
    howpublished = {\url{https://www.tigera.io/learn/guides/ebpf/ebpf-xdp/}},
    year = {2024},
    month = {October},
    note = {Accessed: 2025-03-31},
}


@inproceedings{SPECTRE_BPF_MITIGATION,
    series = {RAID â€™24},
    title = {VeriFence: Lightweight and Precise Spectre Defenses for Untrusted
             Linux Kernel Extensions},
    url = {http://dx.doi.org/10.1145/3678890.3678907},
    DOI = {10.1145/3678890.3678907},
    booktitle = {The 27th International Symposium on Research in Attacks,
                 Intrusions and Defenses},
    publisher = {ACM},
    author = {Gerhorst, Luis and Herzog, Henriette and WÃ¤gemann, Peter and Ott,
              Maximilian and Kapitza, RÃ¼diger and HÃ¶nig, Timo},
    year = {2024},
    month = sep,
    pages = {644â€“659},
    collection = {RAID â€™24},
}

@online{BPF_LOOP_COMMIT,
    author = {The Linux Kernel Community},
    title = {bpf: Add bpf\_loop helper},
    year = {2024},
    month = {3},
    day = {12},
    url = {
           https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=e6f2dd0f80674e9d5960337b3e9c2a242441b326
           },
    urldate = {2025-03-31},
    note = {Commit e6f2dd0, Linux kernel Git repository},
}

@online{BPF_VERIFIER_EXPLOIT,
    author = {Google Bug Hunters},
    title = {A Deep Dive into CVE-2023-2163: How We Found and Fixed an eBPF
             Linux Kernel Vulnerability},
    date = {2024-09-15},
    url = {
           https://bughunters.google.com/blog/6303226026131456/a-deep-dive-into-cve-2023-2163-how-we-found-and-fixed-an-ebpf-linux-kernel-vulnerability
           },
    urldate = {2025-03-31},
}


@book{LINUX_NETWORKING_OBSERVABILITY,
    title = {Linux Observability with BPF: Advanced Programming for Performance
             Analysis and Networking},
    author = {Calavera, D. and Fontana, L.},
    isbn = {9781492050179},
    lccn = {2020276779},
    url = {https://books.google.co.uk/books?id=jtS-DwAAQBAJ},
    year = {2019},
    publisher = {O'Reilly Media},
}


@online{CILIUM_BPF_XDP_INTRO,
    title = {Introduction â€” Cilium 1.18.0-dev documentation},
    author = {{Cilium Authors}},
    year = {2024},
    url = {https://docs.cilium.io/en/latest/network/ebpf/intro/},
    note = {Accessed: 2025-04-02},
}


@online{GREGG_BPF_NOT_SECURITY,
    title = {eBPF Observability Tools Are Not Security Tools},
    author = {Brendan Gregg},
    year = {2023},
    month = apr,
    url = {
           https://www.brendangregg.com/blog/2023-04-28/ebpf-security-issues.html
           },
    note = {Accessed: 2025-04-02},
}


@unpublished{StarovoitovBPFSecurity,
    author = {Starovoitov, Alexei},
    title = {BPF and Security. Friends and Foes},
    year = {2024},
    note = {Talk presented at the Linux Security Foundation Conference, Location
            },
    url = {https://www.youtube.com/watch?v=kvt4wdXEuRU},
}

@misc{seccompBPF,
    author = {{The Linux Kernel Team}},
    title = {{Seccomp BPF (SECure COMPuting with filters) â€” The Linux Kernel
             Documentation}},
    year = {2019},
    howpublished = {\url{
                    https://www.kernel.org/doc/html/v5.0/userspace-api/seccomp_filter.html
                    }},
    note = {Accessed: 2025-04-02},
}


@misc{arcangeli_seccomp_2005,
    author = {Andrea Arcangeli and Andrew Morton and Linus Torvalds},
    title = {[PATCH] seccomp: secure computing support},
    year = 2005,
    note = {Commit message. Accessed: 2025-03-31},
    url = {
           https://archive.ph/20130415050745/http://git.kernel.org/?p=linux/kernel/git/tglx/history.git;a=commit;h=d949d0ec9c601f2b148bed3cdb5f87c052968554
           },
}

@article{GRID_COMPUTING_INTRO,
    title = {Introduction to grid computing},
    author = {Jacob, Bart and Brown, Michael and Fukui, Kentaro and Trivedi,
              Nihar and others},
    journal = {IBM redbooks},
    pages = {3--6},
    year = {2005},
    publisher = {Citeseer},
}


@misc{MAN_PAGES_SECCOMP,
    author = {{Michael Kerrisk}},
    title = {{seccomp(2) â€” operate on Secure Computing state of the process}},
    howpublished = {\url{https://man7.org/linux/man-pages/man2/seccomp.2.html}},
    note = {Linux manual page},
    year = {2024},
    accessed = {2025-04-02},
}


@online{TORVALDS_ANYONE_USES_SECCOMP,
    author = {Linus Torvalds},
    title = {Re: [PATCH 2/2] x86-64: seccomp: fix 32/64 syscall hole},
    year = {2009},
    month = feb,
    day = {28},
    url = {https://lkml.org/lkml/2009/2/28/129},
    note = {Posted to the Linux Kernel Mailing List (LKML)},
}


@online{android_seccomp_oreo,
    author = {{Android Developers}},
    title = {Seccomp filter in Android O},
    year = {2017},
    url = {
           https://android-developers.googleblog.com/2017/07/seccomp-filter-in-android-o.html
           },
    note = {Accessed: 2025-04-02},
}


@online{docker_seccomp,
    author = {{Docker Documentation}},
    title = {Runtime security with seccomp},
    year = {2023},
    url = {https://docs.docker.com/engine/security/seccomp/},
    note = {Accessed: 2025-04-02},
}


@online{firefox_seccomp,
    author = {Guillaume Destuynder},
    title = {Firefox Seccomp sandbox},
    year = {2012},
    url = {https://wiki.mozilla.org/Security/Sandbox/Seccomp},
    note = {Accessed: 2025-04-02},
}


@book{LINUX_PROGRAMMING_INTERFACE,
    author = {Michael Kerrisk},
    title = {The Linux Programming Interface: A Linux and UNIX System
             Programming Handbook},
    year = {2010},
    publisher = {No Starch Press},
    location = {San Francisco},
    isbn = {9781593272203},
}

@article{RCE_BAD,
    author = {Sayar, Imen and Bartel, Alexandre and Bodden, Eric and Le Traon,
              Yves},
    title = {An In-depth Study of Java Deserialization Remote-Code Execution
             Exploits and Vulnerabilities},
    year = {2023},
    issue_date = {January 2023},
    publisher = {Association for Computing Machinery},
    address = {New York, NY, USA},
    volume = {32},
    number = {1},
    issn = {1049-331X},
    url = {https://doi.org/10.1145/3554732},
    doi = {10.1145/3554732},
    abstract = {Nowadays, an increasing number of applications use
                deserialization. This technique, based on rebuilding the instance
                of objects from serialized byte streams, can be dangerous since
                it can open the application to attacks such as remote code
                execution (RCE) if the data to deserialize is originating from an
                untrusted source. Deserialization vulnerabilities are so critical
                that they are in OWASPÕs list of top 10 security risks for web
                applications. This is mainly caused by faults in the development
                process of applications and by flaws in their dependencies, i.e.,
                flaws in the libraries used by these applications. No previous
                work has studied deserialization attacks in-depth: How are they
                performed? How are weaknesses introduced and patched? And for how
                long are vulnerabilities present in the codebase? To yield a
                deeper understanding of this important kind of vulnerability, we
                perform two main analyses: one on attack gadgets, i.e.,
                exploitable pieces of code, present in Java libraries, and one on
                vulnerabilities present in Java applications. For the first
                analysis, we conduct an exploratory large-scale study by running
                256515 &nbsp;experiments in which we vary the versions of
                libraries for each of the 19 publicly available exploits. Such
                attacks rely on a combination of gadgets present in one or
                multiple Java libraries. A gadget is a method which is using
                objects or fields that can be attacker-controlled. Our goal is to
                precisely identify library versions containing gadgets and to
                understand how gadgets have been introduced and how they have
                been patched. We observe that the modification of one
                innocent-looking detail in a class Ð such as making it public Ð
                can already introduce a gadget. Furthermore, we noticed that
                among the studied libraries, 37.5\% are not patched, leaving
                gadgets available for future attacks.For the second analysis, we
                manually analyze 104 deserialization vulnerabilities CVEs to
                understand how vulnerabilities are introduced and patched in
                real-life Java applications. Results indicate that the
                vulnerabilities are not always completely patched or that a
                workaround solution is proposed. With a workaround solution,
                applications are still vulnerable since the code itself is
                unchanged.},
    journal = {ACM Trans. Softw. Eng. Methodol.},
    month = feb,
    articleno = {25},
    numpages = {45},
    keywords = {Serialization, deserialization, vulnerabilities, gadget, remote
                code execution RCE},
}

@misc{apache-prefork-2.4,
    author = {{Apache Software Foundation}},
    title = {prefork MPM --- Apache HTTP Server Version 2.4 Documentation},
    year = {2025},
    howpublished = {\url{ https://httpd.apache.org/docs/2.4/mod/prefork.html }},
    note = {Accessed: 24 April 2025},
}

@misc{nginx-inside-performance-scale-2015,
    author = {{NGINX, Inc.}},
    title = {Inside NGINX: How We Designed for Performance \& Scale},
    year = {2015},
    month = jun,
    howpublished = {\url{
                    https://blog.nginx.org/blog/inside-nginx-how-we-designed-for-performance-scale
                    }},
    note = {Accessed: 24 April 2025},
}

@misc{glibc-dl-map-segments-h,
    author = {{GNU C Library}},
    title = {dl\-map\-segments.h Source Code},
    year = {2025},
    howpublished = {\url{
                    https://codebrowser.dev/glibc/glibc/elf/dl-map-segments.h.html
                    }},
    note = {Accessed: 24 April 2025},
}

@online{halinen-security-risks-sidecar-containers-2024,
    author = {Aarni Halinen},
    title = {Security Risks for Sidecar Containers in Kubernetes},
    institution = {Aalto University},
    year = {2024},
    month = jan,
    url = {https://aaltodoc.aalto.fi/items/d6febcaa-09e4-4bdd-acda-0feb49a5b9f5},
    urldate = {2025-04-24},
}

@online{ebpf-helper-functions-2025,
    author = {{eBPF.io}},
    title = {Helper Functions},
    date = {2025-01-24},
    url = {https://docs.ebpf.io/linux/helper-function/},
    urldate = {2025-04-24},
}

@online{ebpf-bpf-probe-read-user-2024,
    author = {{eBPF.io}},
    title = {Helper Function \texttt{bpf\_probe\_read\_user}},
    date = {2024-08-25},
    url = {https://docs.ebpf.io/linux/helper-function/bpf_probe_read_user/},
    urldate = {2025-04-24},
}

@book{gregg-bpf-performance-tools-2019,
    author = {Brendan Gregg},
    title = {BPF Performance Tools: Linux System and Application Observability},
    publisher = {Addison-Wesley Professional},
    address = {Boston, MA},
    year = {2019},
    month = nov,
    isbn = {9780136554820},
}

@online{kbuild-modules-linux-kernel-docs-2025,
    author = {{The Linux Kernel Documentation}},
    title = {Building External Modules},
    year = {2025},
    url = {https://docs.kernel.org/kbuild/modules.html},
    urldate = {2025-04-24},
}


@article{pointer-based-ds-slow,
    author = {Chilimbi, T.M. and Hill, M.D. and Larus, J.R.},
    journal = {Computer},
    title = {Making pointer-based data structures cache conscious},
    year = {2000},
    volume = {33},
    number = {12},
    pages = {67-74},
    keywords = {Data structures;Prefetching;Costs;Random access
                memory;Hardware;Delay;Programming
                profession;Arithmetic;Multithreading;Scheduling},
    doi = {10.1109/2.889095},
}

@online{linux-kernel-docs-ktime-accessors-2025,
    author = {{The Linux Kernel Documentation}},
    title = {ktime Accessors},
    year = {2025},
    url = {https://docs.kernel.org/core-api/timekeeping.html#c.ktime_get},
    urldate = {2025-04-24},
}

@online{ebpf-bpf-ktime-get-ns-2025,
    author = {{eBPF.io}},
    title = {Helper Function \texttt{bpf\_ktime\_get\_ns}},
    date = {2025-03-15},
    url = {https://docs.ebpf.io/linux/helper-function/bpf_ktime_get_ns/},
    urldate = {2025-04-24},
}

@article{OPTIMUS,
    author = {Yang, Seungyong and Kang, Brent Byunghoon and Nam, Jaehyun},
    title = {Optimus: Association-Based Dynamic System Call Filtering for
             Container Attack Surface Reduction},
    journal = {Journal of Cloud Computing: Advances, Systems and Applications},
    volume = {13},
    pages = {71},
    year = {2024},
    month = {Mar},
    doi = {10.1186/s13677-024-00639-3},
    url = {https://doi.org/10.1186/s13677-024-00639-3},
}

@inproceedings{SYSPART,
    author = {Rajagopalan, Vidya Lakshmi and Kleftogiorgos, Konstantinos and G\"
              {o}ktas, Enes and Xu, Jun and Portokalidis, Georgios},
    title = {SysPart: Automated Temporal System Call Filtering for Binaries},
    year = {2023},
    isbn = {9798400700507},
    publisher = {Association for Computing Machinery},
    address = {New York, NY, USA},
    url = {https://doi.org/10.1145/3576915.3623207},
    doi = {10.1145/3576915.3623207},
    abstract = {Restricting the system calls available to applications reduces
                the attack surface of the kernel and limits the functionality
                available to compromised applications. Recent approaches
                automatically identify the system calls required by programs to
                block unneeded ones. For servers, they even consider different
                phases of execution to tighten restrictions after initialization
                completes. However, they require access to the source code for
                applications and libraries, depend on users identifying when the
                server transitions from initialization to serving clients, or do
                not account for dynamically-loaded libraries. This paper
                introduces SYSPART, an automatic system-call filtering system
                designed for binary-only server programs that addresses the above
                limitations. Using a novel algorithm that combines static and
                dynamic analysis, SYSPART identifies the serving phases of all
                working threads of a server. Static analysis is used to compute
                the system calls required during the various serving phases in a
                sound manner, and dynamic observations are only used to
                complement static resolution of dynamically-loaded libraries when
                necessary. We evaluated SYSPART using six popular servers on
                x86-64 Linux to demonstrate its effectiveness in automatically
                identifying serving phases, generating accurate system-call
                filters, and mitigating attacks. Our results show that SYSPART
                outperforms prior binary-only approaches and performs comparably
                to source-code approaches.},
    booktitle = {Proceedings of the 2023 ACM SIGSAC Conference on Computer and
                 Communications Security},
    pages = {1979Ð1993},
    numpages = {15},
    keywords = {attack-surface reduction, binary analysis, exploit mitigation,
                system-call filtering, temporal},
    location = {Copenhagen, Denmark},
    series = {CCS '23},
}

@inproceedings{SYSFILTER,
    author = {Nicholas DeMarinis and Kent Williams-King and Di Jin and Rodrigo
              Fonseca and Vasileios P. Kemerlis},
    title = {sysfilter: Automated System Call Filtering for Commodity Software},
    booktitle = {23rd International Symposium on Research in Attacks, Intrusions
                 and Defenses (RAID 2020)},
    year = {2020},
    isbn = {978-1-939133-18-2},
    address = {San Sebastian},
    pages = {459--474},
    url = {https://www.usenix.org/conference/raid2020/presentation/demarinis},
    publisher = {USENIX Association},
    month = oct,
}

@misc{LINUX_TEST_PROJECT,
    author = {{The Linux Test Project}},
    title = {{Linux Test Project} 1.0 Documentation},
    year = {2025},
    howpublished = {\url{https://linux-test-project.readthedocs.io/en/latest/}},
    note = {Accessed: 2025-04-25},
}


@inproceedings{ASLR_GUARD,
    author = {Lu, Kangjie and Song, Chengyu and Lee, Byoungyoung and Chung,
              Simon P. and Kim, Taesoo and Lee, Wenke},
    title = {ASLR-Guard: Stopping Address Space Leakage for Code Reuse Attacks},
    year = {2015},
    isbn = {9781450338325},
    publisher = {Association for Computing Machinery},
    address = {New York, NY, USA},
    url = {https://doi.org/10.1145/2810103.2813694},
    doi = {10.1145/2810103.2813694},
    abstract = {A general prerequisite for a code reuse attack is that the
                attacker needs to locate code gadgets that perform the desired
                operations and then direct the control flow of a vulnerable
                application to those gadgets. Address Space Layout Randomization
                (ASLR) attempts to stop code reuse attacks by making the first
                part of the prerequisite unsatisfiable. However, research in
                recent years has shown that this protection is often defeated by
                commonly existing information leaks, which provides attackers
                clues about the whereabouts of certain code gadgets. In this
                paper, we present ASLR-Guard, a novel mechanism that completely
                prevents the leaks of code pointers, and render other information
                leaks (e.g., the ones of data pointers) useless in deriving code
                address. The main idea behind ASLR-Guard is to render leak of
                data pointer useless in deriving code address by separating code
                and data, provide a secure storage for code pointers, and encode
                the code pointers when they are treated as data. ASLR-Guard can
                either prevent code pointer leaks or render their leaks harmless.
                That is, ASLR-Guard makes it impossible to overwrite code
                pointers with values that point to or will hijack the control
                flow to a desired address when the code pointers are
                dereferenced. We have implemented a prototype of ASLR-Guard,
                including a compilation toolchain and a C/C++ runtime. Our
                evaluation results show that (1) ASLR-Guard supports normal
                operations correctly; (2) it completely stops code address leaks
                and can resist against recent sophisticated attacks; (3) it
                imposes almost no runtime overhead (< 1\%) for C/C++ programs in
                the SPEC benchmark. Therefore, ASLR-Guard is very practical and
                can be applied to secure many applications.},
    booktitle = {Proceedings of the 22nd ACM SIGSAC Conference on Computer and
                 Communications Security},
    pages = {280¿291},
    numpages = {12},
    keywords = {randomization, information leak, code reuse attack, ASLR},
    location = {Denver, Colorado, USA},
    series = {CCS '15},
}
@inproceedings{DYNAMIC_LINKERS_OS,
    author = {Castes, Charly and Ghosn, Adrien},
    title = {Dynamic Linkers Are the Narrow Waist of Operating Systems},
    year = {2023},
    isbn = {9798400704048},
    publisher = {Association for Computing Machinery},
    address = {New York, NY, USA},
    url = {https://doi.org/10.1145/3623759.3624548},
    doi = {10.1145/3623759.3624548},
    abstract = {While software applications, programming languages, and hardware
                have changed, operating systems have not. Widely-used commodity
                operating systems are still modelled after the ones designed in
                the seventies. The accumulated burden of backward compatibility
                with the large software ecosystems that run our workloads
                prevents systems from embracing more efficient and disruptive
                designs explored by the system research community.This paper
                advocates a fresh approach to operating system research, where
                innovations are incrementally integrated into operating systems,
                without disrupting existing software, to gradually reshape our
                daily-use systems. The dynamic linker emerges as a pivotal
                element in this transformation process, redefining system
                behavior. The paper outlines specific use cases, covering
                performance enhancements, strengthened security measures,
                streamlined software deployment, and enriched programming
                language abstractions. Additionally, the paper introduces Spidl,
                an experimental modular dynamic linker to facilitate the
                exploration of this promising new research avenue.},
    booktitle = {Proceedings of the 12th Workshop on Programming Languages and
                 Operating Systems},
    pages = {26¿33},
    numpages = {8},
    location = {Koblenz, Germany},
    series = {PLOS '23},
}

@online{kilroy2022linker,
    author = {Andrew Kilroy},
    title = {Re: [PATCH v2 7/8] arm64: mm: Add support for loading kernel at a
             fixed offset},
    year = {2022},
    url = {
           https://lore.kernel.org/linux-arm-kernel/20220704145333.22557-8-andrew.kilroy@arm.com/T/
           },
    note = {Linux ARM Kernel Mailing List},
    urldate = {2025-04-28},
}

@inproceedings{gregg2014linux,
    author = {Brendan Gregg},
    title = {Linux Performance Analysis: New Tools and Old Secrets},
    booktitle = {Proceedings of the 28th Large Installation System
                 Administration Conference (LISA14)},
    year = {2014},
    organization = {USENIX Association},
    address = {Seattle, WA},
    url = {
           https://www.usenix.org/sites/default/files/conference/protected-files/lisa14_slides_gregg.pdf
           },
    note = {Invited Talk},
    urldate = {2025-04-28},
}

@book{love2005linux,
    author = {Robert Love},
    title = {Linux Kernel Development},
    edition = {2},
    publisher = {Sams Publishing},
    year = {2005},
    isbn = {9780672327209},
    url = {
           https://litux.nl/mirror/kerneldevelopment/0672327201/ch14lev1sec2.html
           },
    note = {Accessed: 2025-04-28},
}


@misc{yang2024makingsyscallprivilegeright,
    title = {Making 'syscall' a Privilege not a Right},
    author = {Fangfei Yang and Anjo Vahldiek-Oberwagner and Chia-Che Tsai and
              Kelly Kaoudis and Nathan Dautenhahn},
    year = {2024},
    eprint = {2406.07429},
    archivePrefix = {arXiv},
    primaryClass = {cs.CR},
    url = {https://arxiv.org/abs/2406.07429},
}

@inproceedings{SYSCALL_RANKINGS,
    author = {Mussa, Awad A Younis and Malaiya, Yashwant and Ray, Indrajit},
    year = {2014},
    month = {01},
    pages = {1-8},
    title = {Using Attack Surface Entry Points and Reachability Analysis to
             Assess the Risk of Software Vulnerability Exploitability},
    journal = {Proceedings - 2014 IEEE 15th International Symposium on
               High-Assurance Systems Engineering, HASE 2014},
    doi = {10.1109/HASE.2014.10},
}

@online{HeiserBenchmarkingCrimes,
    author = {Heiser, Gernot},
    title = {Benchmarking Crimes},
    url = {https://gernot-heiser.org/benchmarking-crimes.html},
    urldate = {2025-04-30},
}

@inproceedings{WRITES_ARE_SEQUENTIAL,
    author = {Humbetov, Shamil},
    booktitle = {2012 6th International Conference on Application of Information
                 and Communication Technologies (AICT)},
    title = {Data-intensive computing with map-reduce and hadoop},
    year = {2012},
    volume = {},
    number = {},
    pages = {1-5},
    keywords = {File systems;Google;Computers;Data processing;Distributed
                databases;Computational modeling;Servers;Hadoop;MapReduce;Data
                Intensive Computing},
    doi = {10.1109/ICAICT.2012.6398489},
}

@manual{fio-docs,
    title = {fio - Flexible I/O Tester Documentation},
    author = {{Jens Axboe and Contributors}},
    organization = {fio Project},
    year = {2025},
    url = {https://fio.readthedocs.io/en/latest/fio_doc.html},
    note = {Accessed: 2025-05-01},
}

@manual{process_vm_readv,
    title = {process\_vm\_readv(2) Ñ Linux manual page},
    subtitle = {Transfer data between the address spaces of processes},
    author = {{Michael Kerrisk and Contributors}},
    organization = {man7.org},
    year = {2025},
    url = {https://man7.org/linux/man-pages/man2/process_vm_readv.2.html},
    note = {Accessed: 2025-05-01},
}

@manual{perf_event_open,
    title = {perf\_event\_open(2) ¿ Linux manual page},
    subtitle = {Set up performance monitoring},
    author = {{Michael Kerrisk and Contributors}},
    organization = {man7.org},
    year = {2025},
    url = {https://man7.org/linux/man-pages/man2/perf_event_open.2.html},
    note = {Accessed: 2025-05-01},
}

@inproceedings{shacham2007rop,
    title = {The geometry of innocent flesh on the bone: Return-into-libc
             without function calls ()},
    author = {Shacham, Hovav},
    booktitle = {Proceedings of the 14th ACM Conference on Computer and
                 Communications Security (CCS)},
    pages = {552--561},
    year = {2007},
    publisher = {ACM},
}

@inproceedings{ernst2007daikon,
    title = {The Daikon system for dynamic detection of likely invariants},
    author = {Ernst, Michael D and Cockrell, Jake and Griswold, William G and
              Notkin, David},
    journal = {Science of Computer Programming},
    volume = {69},
    number = {1-3},
    pages = {35--45},
    year = {2007},
    publisher = {Elsevier},
}

@inproceedings{lerner2019gvisor,
    title = {gVisor: Contemporary Container Sandbox},
    author = {Lerner, Ian and Muthusamy, Pratyush and DeMarinis, Nicholas and
              Garfinkel, Tal and Lee, Wyatt and Ragsdale, Ray and Bauman, Felix
              and Jin, Yushi and Arya, Dhruv and Taylor, Brandon and others},
    booktitle = {16th USENIX Symposium on Networked Systems Design and
                 Implementation (NSDI 19)},
    pages = {691--705},
    year = {2019},
}

@inproceedings{somayaji2000automated,
    title = {Automated response using $\{$System-Call$\}$ delay},
    author = {Somayaji, Anil and Forrest, Stephanie},
    booktitle = {9th USENIX security symposium (USENIX security 00)},
    year = {2000},
}

@inproceedings{garfinkel2004ostia,
    title = {Ostia: A delegating architecture for secure system call
             interposition.},
    author = {Garfinkel, Tal and Pfaff, Ben and Rosenblum, Mendel and others},
    booktitle = {NDSS},
    year = {2004},
    organization = {Citeseer},
}

@inproceedings{sandbox-adoption,
    author = {Alhindi, Maysara and Hallett, Joseph},
    title = {Sandboxing Adoption in Open Source Ecosystems},
    year = {2024},
    isbn = {9798400705571},
    publisher = {Association for Computing Machinery},
    address = {New York, NY, USA},
    url = {https://doi.org/10.1145/3643655.3643878},
    doi = {10.1145/3643655.3643878},
    abstract = {Sandboxing mechanisms allow developers to limit how much access
                applications have to resources, following the least-privilege
                principle. However, it's not clear how much and in what ways
                developers are using these mechanisms. This study looks at the
                use of Seccomp, Landlock, Capsicum, Pledge, and Unveil in all
                packages of four open-source operating systems. We found that
                less than 1\% of packages directly use these mechanisms, but many
                more indirectly use them. Examining how developers apply these
                mechanisms reveals interesting usage patterns, such as cases
                where developers simplify their sandbox implementation. It also
                highlights challenges that may be hindering the widespread
                adoption of sandboxing mechanisms.},
    booktitle = {Proceedings of the 12th ACM/IEEE International Workshop on
                 Software Engineering for Systems-of-Systems and Software
                 Ecosystems},
    pages = {13¿20},
    numpages = {8},
    location = {Lisbon, Portugal},
    series = {SESoS '24},
}

@mastersthesis{wagner1999janus,
    title = {Janus: an approach for confinement of untrusted applications},
    author = {Wagner, David A},
    year = {1999},
    school = {University of California, Berkeley},
}

@online{chromium_sandboxing,
    author = {{The Chromium Project}},
    title = {Linux Sandboxing},
    year = {2023},
    url = {
           https://chromium.googlesource.com/chromium/src/+/refs/tags/112.0.5590.0/docs/linux/sandboxing.md
           },
    urldate = {2025-05-01},
    note = {Accessed: 2025-05-01},
}

@inproceedings{TEMPORAL_SPEC,
    author = {Seyedhamed Ghavamnia and Tapti Palit and Shachee Mishra and
              Michalis Polychronakis},
    title = {Temporal System Call Specialization for Attack Surface Reduction},
    booktitle = {29th USENIX Security Symposium (USENIX Security 20)},
    year = {2020},
    isbn = {978-1-939133-17-5},
    pages = {1749--1766},
    url = {
           https://www.usenix.org/conference/usenixsecurity20/presentation/ghavamnia
           },
    publisher = {USENIX Association},
    month = aug,
}

@inproceedings{SYSXCHG,
    author = {Gaidis, Alexander J. and Atlidakis, Vaggelis and Kemerlis,
              Vasileios P.},
    title = {SysXCHG: Refining Privilege with Adaptive System Call Filters},
    year = {2023},
    isbn = {9798400700507},
    publisher = {Association for Computing Machinery},
    address = {New York, NY, USA},
    url = {https://doi.org/10.1145/3576915.3623137},
    doi = {10.1145/3576915.3623137},
    abstract = {We present the design, implementation, and evaluation of
                SysXCHG: a system call (syscall) filtering enforcement mechanism
                that enables programs to run in accordance with the principle of
                least privilege. In contrast to the current, hierarchical design
                of seccomp-BPF, which does not allow a program to run with a
                different set of allowed syscalls than its descendants, SysXCHG
                enables applications to run with "tight" syscall filters,
                uninfluenced by any future-executed (sub-)programs, by allowing
                filters to be dynamically exchanged at runtime during execve[at].
                As a part of SysXCHG, we also present xfilter: a mechanism for
                fast filtering using a process-specific view of the kernel's
                syscall table where filtering is performed. In our evaluation of
                SysXCHG, we found that our filter exchanging design is performant
                , incurring ²= 1.71\% slowdown on real-world programs in the PaSH
                benchmark suite, as well as effective, blocking vast amounts of
                extraneous functionality, including security-critical syscalls,
                which the current design of seccomp-BPF is unable to.},
    booktitle = {Proceedings of the 2023 ACM SIGSAC Conference on Computer and
                 Communications Security},
    pages = {1964Ð1978},
    numpages = {15},
    keywords = {adaptive filtering, attack surface reduction, system call
                filtering},
    location = {Copenhagen, Denmark},
    series = {CCS '23},
}

@misc{jia2023programmablesecurityebpf,
    title = {Programmable System Call Security with eBPF},
    author = {Jinghao Jia and YiFei Zhu and Dan Williams and Andrea Arcangeli
              and Claudio Canella and Hubertus Franke and Tobin Feldman-Fitzthum
              and Dimitrios Skarlatos and Daniel Gruss and Tianyin Xu},
    year = {2023},
    eprint = {2302.10366},
    archivePrefix = {arXiv},
    primaryClass = {cs.OS},
    url = {https://arxiv.org/abs/2302.10366},
}

@inproceedings{ahad2023freepart,
    title = {FreePart: Hardening Data Processing Software via Framework-based
             Partitioning and Isolation},
    author = {Ahad, Ali and Wang, Gang and Kim, Chung Hwan and Jana, Suman and
              Lin, Zhiqiang and Kwon, Yonghwi},
    booktitle = {Proceedings of the 28th ACM International Conference on
                 Architectural Support for Programming Languages and Operating
                 Systems, Volume 4},
    pages = {169--188},
    year = {2023},
}

@online{cilium2025,
    author = {{Cilium Project}},
    title = {Cilium: eBPF-based Networking, Observability, and Security},
    year = {2025},
    url = {https://cilium.io/},
    urldate = {2025-05-01},
}

@misc{falco2025,
    author = {{Falco Project}},
    title = {Falco: Cloud Native Runtime Security},
    year = {2025},
    howpublished = {\url{https://falco.org/}},
    note = {Accessed: 2025-05-01},
}

@misc{tetragon2025,
    author = {{Tetragon Project}},
    title = {Tetragon: eBPF-based Security Observability and Runtime Enforcement
             },
    year = {2025},
    howpublished = {\url{https://tetragon.io/}},
    note = {Accessed: 2025-05-01},
}



@article{XING2022105,
    title = {The devil is in the detail: Generating system call whitelist for
             Linux seccomp},
    journal = {Future Generation Computer Systems},
    volume = {135},
    pages = {105-113},
    year = {2022},
    issn = {0167-739X},
    doi = {https://doi.org/10.1016/j.future.2022.04.016},
    url = {https://www.sciencedirect.com/science/article/pii/S0167739X2200139X},
    author = {Yunlong Xing and Jiahao Cao and Kun Sun and Fei Yan and Shengye
              Wan},
    keywords = {System call restriction, Attack surface reduction, Whitelist
                generation, Software security, System enhancement, Static
                analysis},
    abstract = {The system calls provide the main interface for user processes
                to request the kernel services, however, for any specific process
                , most of them will not be needed. If a user process is
                compromised, those unnecessary system calls can be abused to
                attack the kernel and the other processes. To migrate this
                problem, the seccomp mechanism has been merged into the Linux
                kernel to limit the available system calls according to a system
                call whitelist. However, it is still a challenge to automatically
                and effectively generate a minimal but complete system call
                whitelist for a specific user process. In this paper, we develop
                a toolkit named TAILOR that mainly relies on the static analysis
                to generate a mapping table for the standard library from the
                library functions to their corresponding system calls based on
                the source code analysis. Then for any application that invokes
                system calls via the standard library, we can just compare the
                called library functions in the application with the mapping
                table to obtain required system calls. TAILOR solves the problems
                during source-level standard library analysis, which consist of
                the difficulty in macro function identification, unchained
                calling tree caused by macro aliases, and the difficulty in
                identifying the function scope via static analysis. Our
                experiments on 50 popular general terminal commands show that our
                tool can reduce 88% system calls for them and block about 74%
                potential vulnerabilities from malicious system calls.},
}

@online{angr2025,
    author = {{The angr Project}},
    title = {angr: A Powerful and User-Friendly Binary Analysis Platform},
    year = {2025},
    url = {https://angr.io/},
    urldate = {2025-05-01},
}

@inproceedings{BSIDE,
    author = {Gaspard Th{\'e}venon and Kevin Nguetchouang and Kahina Lazri and
              Alain Tchana and Pierre Olivier},
    title = {B-Side: Binary-Level Static System Call Identification},
    booktitle = {Proceedings of the 25th International Middleware Conference
                 (Middleware '24)},
    year = {2024},
    pages = {225--237},
    publisher = {Association for Computing Machinery},
    address = {New York, NY, USA},
    doi = {10.1145/3652892.3700761},
    url = {https://doi.org/10.1145/3652892.3700761},
    isbn = {979-8-4007-0623-3},
    keywords = {static analysis, binary analysis, system call filtering},
    abstract = {System call filtering is widely used to secure programs in
                multi-tenant environments, and to sandbox applications in modern
                desktop software deployment and package management systems.
                Filtering rules are hard to write and maintain manually, hence
                generating them automatically is essential. To that aim, analysis
                tools able to identify every system call that can legitimately be
                invoked by a program are needed. Existing static analysis works
                lack precision because of a high number of false positives,
                and/or assume the availability of program/libraries source code -
                something unrealistic in many scenarios such as cloud production
                environments. We present B-Side, a static binary analysis tool
                able to identify a superset of the system calls that an x86-64
                static/dynamic executable may invoke at runtime. B-Side assumes
                no access to program/libraries sources, and shows a good degree
                of precision by leveraging symbolic execution, combined with a
                heuristic to detect system call wrappers, which represent an
                important source of precision loss in existing works. B-Side also
                allows to statically detect phases of execution in a program in
                which different filtering rules can be applied. We validate
                B-Side and demonstrate its higher precision compared to
                state-of-the-art works: over a set of popular applications,
                B-Side's average F1 score is 0.81, vs. 0.31 and 0.53 for
                competitors. Over 557 static and dynamically-compiled binaries
                taken from the Debian repositories, B-Side identifies an average
                of 43 system calls, vs. 271 and 95 for two state-of-the art
                competitors. We further evaluate the strictness of the
                phase-based filtering policies that can be obtained with B-Side.},
    location = {Hong Kong, Hong Kong},
    numpages = {13},
    series = {Middleware '24},
}

@inproceedings{JENNY,
    author = {David Schrammel and Samuel Weiser and Richard Sadek and Stefan
              Mangard},
    title = {Jenny: Securing Syscalls for {PKU-based} Memory Isolation Systems},
    booktitle = {31st USENIX Security Symposium (USENIX Security 22)},
    year = {2022},
    isbn = {978-1-939133-31-1},
    address = {Boston, MA},
    pages = {936--952},
    url = {
           https://www.usenix.org/conference/usenixsecurity22/presentation/schrammel
           },
    publisher = {USENIX Association},
    month = aug,
}

@inproceedings{CHERI,
    author = {Woodruff, Jonathan and Watson, Robert N.M. and Chisnall, David and
              Moore, Simon W. and Anderson, Jonathan and Davis, Brooks and Laurie
              , Ben and Neumann, Peter G. and Norton, Robert and Roe, Michael},
    title = {The CHERI capability model: revisiting RISC in an age of risk},
    year = {2014},
    isbn = {9781479943944},
    publisher = {IEEE Press},
    abstract = {Motivated by contemporary security challenges, we reevaluate and
                refine capability-based addressing for the RISC era. We present
                CHERI, a hybrid capability model that extends the 64-bit MIPS ISA
                with byte-granularity memory protection. We demonstrate that
                CHERI enables language memory model enforcement and fault
                isolation in hardware rather than software, and that the CHERI
                mechanisms are easily adopted by existing programs for efficient
                in-program memory safety. In contrast to past capability models,
                CHERI complements, rather than replaces, the ubiquitous
                page-based protection mechanism, providing a migration path
                towards deconflating data-structure protection and OS memory
                management. Furthermore, CHERI adheres to a strict RISC
                philosophy: it maintains a load-store architecture and requires
                only singlecycle instructions, and supplies protection primitives
                to the compiler, language runtime, and operating system. We
                demonstrate a mature FPGA implementation that runs the FreeBSD
                operating system with a full range of software and an open-source
                application suite compiled with an extended LLVM to use CHERI
                memory protection. A limit study compares published memory safety
                mechanisms in terms of instruction count and memory overheads.
                The study illustrates that CHERI is performance-competitive even
                while providing assurance and greater flexibility with simpler
                hardware},
    booktitle = {Proceeding of the 41st Annual International Symposium on
                 Computer Architecuture},
    pages = {457¿468},
    numpages = {12},
    location = {Minneapolis, Minnesota, USA},
    series = {ISCA '14},
}

@article{SALTZER_SCHROEDER,
    author = {Saltzer, J.H. and Schroeder, M.D.},
    journal = {Proceedings of the IEEE},
    title = {The protection of information in computer systems},
    year = {1975},
    volume = {63},
    number = {9},
    pages = {1278-1308},
    keywords = {Protection;Authorization;Permission;Access
                control;Terminology;Data security;Information security;Computer
                architecture;Modems},
    doi = {10.1109/PROC.1975.9939},
}

@online{bpf-man-pages,
    title = {bpf(2) - Linux manual page},
    author = {{The Linux man-pages project}},
    year = {2025},
    url = {https://man7.org/linux/man-pages/man2/bpf.2.html},
    urldate = {2025-05-04},
    note = {Accessed: 2025-05-04},
}

@online{rice_fastabend_ebpf_turing_2024,
  author    = {Liz Rice and John Fastabend},
  title     = {eBPF: Yes, itÕs Turing Complete!},
  year      = {2024},
  month     = sep,
  url       = {https://isovalent.com/blog/post/ebpf-yes-its-turing-complete/},
  urldate   = {2025-05-04},
  note      = {Accessed: 2025-05-04}
}

@inbook{LAMPORT_CLOCKS,
author = {Lamport, Leslie},
title = {Time, clocks, and the ordering of events in a distributed system},
year = {2019},
isbn = {9781450372701},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3335772.3335934},
booktitle = {Concurrency: The Works of Leslie Lamport},
pages = {179Ð196},
numpages = {18}
}

@online{flatpak_seccomp_profile,
  author    = {{Flatpak Project Contributors}},
  title     = {flatpak-docker-seccomp.json Ñ Flatpak Seccomp Profile},
  year      = {2025},
  url       = {https://github.com/flatpak/flatpak/blob/main/data/flatpak-docker-seccomp.json},
  urldate   = {2025-05-04},
  note      = {Accessed: 2025-05-04}
}

@online{openssh60,
  author    = {{OpenSSH Project}},
  title     = {OpenSSH 6.0 Release Notes},
  year      = {2012},
  month     = apr,
  url       = {https://www.openssh.com/txt/release-6.0},
  urldate   = {2025-05-04},
  note      = {Accessed: 2025-05-04}
}

@manual{tensorflow2015,
  title        = {TensorFlow: Large-scale machine learning on heterogeneous systems},
  author       = {{Mart’n Abadi} and {Ashish Agarwal} and {Paul Barham} and {Eugene Brevdo} and {Zhifeng Chen} and {et al.}},
  organization = {Google Brain Team},
  year         = {2015},
  note         = {Software available from https://www.tensorflow.org},
  url          = {https://www.tensorflow.org},
  urldate      = {2025-05-04}
}

@article{opencv_library,
  author  = {Gary Bradski},
  title   = {The OpenCV Library},
  journal = {Dr. Dobb's Journal of Software Tools},
  year    = {2000},
  url     = {https://opencv.org},
  urldate = {2025-05-04}
}
