\section{Background} \label{sec:background}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% GEMINI GENERATED PLAN
% eBPF (Extended Berkeley Packet Filter): Explain what eBPF is, its origins (from
% packet filtering), how it allows running sandboxed programs within the Linux
% kernel without changing kernel source code or loading modules, and its
% common use cases (networking, observability, security).   

% Linux Tracepoints (specifically raw_tp/sys_enter): Describe what
% tracepoints are (static kernel instrumentation points) and specifically the
% raw_tp/sys_enter tracepoint, why it's used (to intercept every system call
% before kernel processing), and how it differs from syscall-specific
% tracepoints.   

% System Call Invocation & Userspace Stack Unwinding: While students know
% what syscalls are, explain the mechanism of how they are typically invoked
% via libraries like libc. Detail the concept of stack unwinding from the
% kernel's perspective to find the true origin of a syscall in the userspace
% application code (the first non-libc return pointer), rather than just the
% final libc wrapper function.
  
% Virtual Memory Areas (VMAs) & File-Backed Regions: Explain how a process's address
% space is organized into VMAs in Linux, particularly how shared libraries map
% to file-backed memory regions. Mention the role of kernel structures like
% vma_struct  and the /proc/PID/maps pseudofile.   

% Mapping Syscall Sites to Shared Libraries: Describe the process of taking a 
% memory address (the identified syscall site from stack unwinding) and
% using the VMA information to determine which specific shared library file
% contains that address.   

% eBPF Maps & Ringbuffers: Explain these specific eBPF data structures used
% for communication and data storage between the eBPF kernel program and the
% userspace frontend (e.g., storing configuration, whitelists, PIDs, passing
% events/stats).   

% eBPF Helper Functions: Briefly mention that eBPF programs cannot call
% arbitrary kernel functions but rely on a specific set of "helper" functions
% provided and verified by the kernel to perform tasks like reading memory, getting
% timestamps, or accessing kernel structures.   

% Seccomp: While addrfilter offers finer granularity, explaining the standard Linux mechanism seccomp (Secure
% Computing mode) for syscall filtering provides important context and a baseline
% for comparison.   

% Software Compartmentalization: Introduce this as a security concept
% relevant to the threat model, where different parts of an application (like
% different shared libraries) might have different privileges or allowed
% actions.   

% Linux Capabilities (specifically CAP_SYS_ADMIN): Explain that root
% privilege in Linux is broken down into capabilities and why CAP_SYS_ADMIN is
% relevant for loading eBPF programs, and the security implications of
% processes inheriting capabilities.   

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\af is a project built on a complex stack of systems technologies such as Linux
processes, system calls, instrumentation points, \ac{bpf}, software
compartmentalisation, and existing Linux security features such as \ac{aslr}.

Pre-requisite knowledge needed to understand \afg motivation, design, and
implementation, is provided in this chapter. \todo{Read ``The Linux Programming
Interface''}

\subsection{Processes and Virtual Memory}

\subsubsection{The Virtual Memory Area}

% what is process virtual memory
% what does it look like in kernel?
% - vma_struct
% - mention vma red-black tree
% file-backed regions: for when a file such as a shared library file (aka shared
% object file) is loaded into a process's address space. This makes the contents
% of the file accessible between some set addresses.

Every process on a Linux machine interacts with memory through the abstraction
that is virtual memory. Instead of interacting with physical memory addresses,
every process's \ac{vma} is numbered from 0 to 256TB\todo{replace this with a
number}. The kernel ensures that processes don't overlap on physical memory and
enforces the permissions associated with each area of the \ac{vma}.

In Linux, each process's \ac{vma} is managed using a
red-black tree where each node contains a reference to a
\texttt{vm\_area\_struct} \todo{inline/appendix listing of vma\_struct
definition}. Every \texttt{vm\_area\_struct} details a specific, contiguous
range within the process's virtual address space. The information stored
includes the start and end addresses of the range, the backing file (if any)
from which the range was populated, and the offset within that file. This file
offset is needed for supporting \acp{pie}, allowing code and data segments to be correctly located even if loaded at different base addresses.

When data is loaded from a file into a process's \ac{vma} it is called a
\textit{file-backed memory region}, visualised in Figure
\ref{fig:file-backed-vma}. This typically spans multiple
\texttt{vm\_area} structs and is almost always contiguous. This is common in dynamically
linked executables, where the object code from a shared library file is made
accessible to the main binary by loading it into the main binary's \ac{vma}. 

\begin{figure}[ht]
    \centering
    \includegraphics[width=0.8 \linewidth]{./diagrams/file-backed-vma.drawio.pdf} 
    \caption{A figure showing a file being loaded into a process's \ac{vma} to
    create a \textit{file backed memory region}. One vertical chunk represents
one address range represented by a \texttt{vm\_area} struct.}
    \label{fig:file-backed-vma}
\end{figure}

As well as containing information about where the data was loaded from, the
\texttt{vm\_area} struct also contains details about page permissions \todo{is it
page permissions?}. This is a Linux security feature which is enforced by the
kernel which lets pages in the \texttt{vm\_area} struct be marked as having read,
write or execute permissions.
\todo{research this properly}

\subsubsection{Existing Security Mechanisms}
% Page permissions (link from vma)
% ASLR: relevant for filtering as we need to track addresses
\todo{diagram showing vma of child after execve with/without aslr}
% Users, user groups and permissions
% Kernel/user seperation for privileged actions

\subsubsection{Kernelspace vs Userspace}
Operating systems have two modes, or \textit{worlds}, associated with them: user
mode and kernel mode. User mode, or userspace, is designed to run untrusted 
applications. There is no direct access to hardware, I/O devices, or the 
network from userspace.

Kernel mode, or kernelspace, on the other hand, is a more privileged environment
than userspace. The kernel has direct access to hardware, memory, and the
network. As such, one can do a lot of damage from kernel space including causing
the kernel to crash.

Therefore, it is vital that only trusted code is run in kernel mode, and that
non-trusted code is only ever run in user mode. This begs the question: if
applications aren't allowed direct access to the hardware, then how do user
applications, such as web browsers, interact with hardware resources? The answer
is via \textbf{system calls}.

% Data transfer between kernelspace and userspace done via syscalls

\subsection{Syscalls}

When an application running in userspace wants to access hardware - for example,
to request a page in memory - it issues a \textbf{system call} (or syscall). System calls
form an \ac{api} which allows userspace programs to ask the kernel to complete some
task, and return the result back to userspace.

In the case of requesting a memory page, the userspace application will make a
call to \texttt{mmap()} from the \acp{os} C standard library (e.g. \texttt{libc}).
This triggers a \textit{world switch}: the process of changing the hardware
to/from kernel mode.

A world switch is a costly operation, involving flushing any virtually mapped
caches and copying all the contents of all \ac{cpu} registers to the user stack. This
is done to ensure a strict separation between kernelspace and userspace, and to
make sure that the userspace process can continue running as usual after the
syscall.

Syscall invocation patterns can serve as indicators of compromise
and are a common feature of host based intrusion detection systems \cite{10.1145/3214304}. 
Applications only need to make a subset of syscalls
- if an app makes a syscall that is not in its source code, that is a clear
indication of compromise. Existing software such as \texttt{seccomp} uses this
to create a \textbf{syscall filter}, killing any processes which make
blacklisted syscalls. 

\texttt{addrfilter} builds on what \texttt{seccomp} does by breaking down the
process's address space into smaller subsections, and assigning a bespoke filter
to each subsection. This design is a form of \textbf{software
compartmentalisation}. 

\subsection{Software Compartmentalisation}
Software compartmentalisation is a form of defensive programming where an
application is broken down into multiple isolated compartments \cite{SOK}. Compartments
communicate only over secure interfaces and do not trust each other. An attacker
who manages to compromise one compartment will not be able to gain access to
data or resources assigned to another compartment. 

Compartmentalisation has proven useful in containing memory safety issues
\cite{CONFFUZZ},
sandboxing untrusted third parties \cite{ANDROID_SOK} or unsafe parts of
languages \cite{MPK} (e.g.
\texttt{unsafe} in Rust \cite{rustbook_unsafe}). Compartmentalisation is also an
application of the principle of least privilege to software \cite{PRIVMAN}.

\texttt{addrfilter} is a work under the umbrella of software
compartmentalisation for this reason: it decomposes the process address space
and restricts which separated units are allowed to make specific syscalls.
This functionality is not trivially supported by common tools used to work with
syscalls such as \texttt{strace}. As such, implementing \texttt{addrfilter}
required writing extensive amounts of kernel code; \ac{bpf} was chosen for this
task.

\subsection{Introducing eBPF}

\ac{bpf} is a technology that allows developers to write custom programs which
can be \textit{dynamically loaded} into the kernel to alter the kernel's
behaviour \cite{LEARNING_EBPF}. 

Writing kernel code without \ac{bpf} is error-prone and typically
requires linking to the kernel \cite{UNDERSTANDING_LINUX_KERNEL}. In contrast,
\ac{bpf} programs can be configured to run on many instrumentation points, such
as a syscall being triggered. \ac{bpf} also provides a \textbf{verifier} which
ensures the  loaded program is safe \cite{LEARNING_EBPF}.
This makes it impossible to cause a kernel panic (or any similarly
catastrophic event) when writing \ac{bpf} although real-world exploits targeting the
verifier have been seen \cite{BPF_VERIFIER_EXPLOIT}. 

As such, \ac{bpf} is used a lot in industry for observability tooling: being able to
dynamically load \ac{bpf} programs allows developers to instrument running processes
without changing any configuration files or using sidecar containers \cite{SIDECAR}.
\ac{bpf} is also often used in networking and firewalls 
\cite{LINUX_NETWORKING_OBSERVABILITY} - a \ac{bpf} program can
be loaded onto the \ac{xdp} to inspect packets at the ``\textit{earliest 
possible point in the network driver}'' \cite{CILIUM_BPF_XDP_INTRO}. 

\subsubsection{The Verifier}

\subsubsection{Communicating with Userspace}
% Maps (not threadsafe)
% Ringbuffers (coords by default)

\subsection{Traditional Syscall Filtering Mechanisms}

\subsubsection{Introducing seccomp}

\subsubsection{Address space limitations}

% discuss => problem; we can apply the principle of least privilege further. 
% Applications getting bigger => one filter becomes too permissive.


This chapter has covered background essential to understanding the need for, and
the design choices behind, \afss. Additional information on the
virtual address space, stack, and filesystem of a process was given. System
calls were introduced as a means of communication between kernel- and userspace.
Software compartmentalisation and its relevance to \af was
discussed, and \ac{bpf} was motivated as the method of choice for writing kernel
code. 

The next section will combine all of this relevant prerequisite knowledge into a
high level design for \afss. 
