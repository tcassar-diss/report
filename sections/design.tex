\section{Design} \label{sec:design}

% The aim of design: write like the larousse. High level design for someone to
% take and improve upon. 
%
% Idea is to motivate that this is well designed and well thought through.
% Key design decisions:
        
% ------------------------
% Design introduction: what is the design philosophy? why?

\af is a complex piece of systems software and therefore required a careful
design phase. In a systems security project, added code and complexity
represent more chances for vulnerabilities to appear. Therefore, it was
important to design \af to be \textit{as minimal as possible} while
fulfilling the promise of the proposed fine-grained filtering.

To do this, we defined a threat model and let primary requirements and
engineering assumptions follow. The project's nature also requires some auxiliary
tooling, which is discussed after \afg design is presented. 

\subsection{Threat Model, Objectives, and Assumptions}\label{subsec:objs-assumpions-tm}

% Threat Model

Designing a concrete implementation of any security tooling requires a threat
model. We begin by laying out the situations and preconditions where \af effectively
protects applications. We establish this model based on the separation
between the untrusted application space and the trusted kernel. 

\af assumes 1) a form of \textit{software compartmentalisation} is implemented
on the host system which will confine an attacker to the compartment that
they have breached. A compartmentalised application is made up of multiple \textit
{security domains} which are mutually distrusting \cite{SOK}. Our
implementation of \af assumes compartment boundaries to be the \textit{shared
libraries} in a process's \ac{vma} as in Figure~\ref{fig:compartments-around-vma},
although the concept can be generalised across the \ac{vma}.

\begin{figure}[ht]
    \centering
    \includegraphics[width=0.96 \linewidth]{./diagrams/compartments-around-so.drawio.pdf} 
    \caption{A diagram showing how compartment boundaries are drawn to align
    with file-backed regions of the process's \ac{vma}.}
    \label{fig:compartments-around-vma}
\end{figure}

We assume 2) an attacker has compromised one or more of these compartments and that
3) they have \textit{arbitrary code execution} within the compartment's context. We
assume 4) the attacker's goal is to exploit a bug in the kernel via a series of
system calls; this could be privilege escalation (e.g. taking over the kernel's
execution flow), leaking/tampering with kernel-critical data, or attempting to
bypass compartmentalisation. 

For completeness, we assume 5) that the attacker does not already have a 
kernel-level exploit and that the process they compromised does not have root
access. This is out of scope as a kernel-level exploit effectively gives the
attacker root access to the host, which results in complete system compromise.

% end Threat Model

% Objectives

Having defined a threat model, we can define and list our objectives.

Our primary objective is to design a system that detects when an application
makes a disallowed system call. Our solution, \af,  must locate the call's origin
within the \ac{vma} and confirm that this memory region has the
appropriate permissions to make the call.

If \af detects a disallowed system call it must intervene in one of three (user
configurable) ways: either it must kill the offending process, warn the user, or
kill every process currently protected by the filter. This allows the user to
choose the trade-off between availability and data integrity/confidentiality on
a per-application basis.

We expect to see a significant reduction in the set of system calls that an
attacker can use to compromise an application without detrimentally impacting
application performance. 

System call literature has not defined a standard for measuring the privilege
of a set of system calls -- therefore, we look to propose our own
\textit{probabilistic} metric to quantify the privilege reduction \af
provides over seccomp.

To summarise:

\begin{enumerate}
    \item \af \textit{shall} associate a distinct system call whitelist with each unique file-backed region within a process's \ac{vma}.
    \item \af \textit{shall} \textbf{identify the specific memory region} within the \ac{vma} from which a system call originates. If the invoked system call is not included in the whitelist associated with that originating region, \af \textit{shall} \textbf{trigger an intervention}.
    \item The intervention action taken by \af upon detecting a non-whitelisted system call \textit{shall} be \textbf{configurable by the user}. The available configuration options \textit{shall} include, at minimum: (a) logging a warning, (b) terminating the process that issued the disallowed system call, and (c) terminating all processes currently being monitored by \af.
    \item \af \textit{shall} demonstrably achieve a \textbf{greater reduction in process privileges} compared to a standard Linux seccomp filter configuration. This security enhancement \textit{shall} be achieved while incurring a runtime performance overhead deemed acceptable within pre-defined limits.
    \item The privilege reduction afforded by \af must be able to be quantified
        with a newly proposed metric.
\end{enumerate}

Given the novel nature of this solution, we cannot use readily available
whitelist generators, as no current solutions identify system call
invocation site. Therefore, we must implement our own \textit{automated whitelist 
generation tool}, \texttt{afgen}. Whitelist generation is a separate research problem and is
orthogonal to our proposed solution. Similarly, we need tooling to identify an
application's system calls for evaluation purposes. For this, we implement
\texttt{syso}.

% end Objectives



Alongside security assumptions, we also make some engineering assumptions when
implementing \af reserved for rare cases which require significant
engineering to cover. In these cases, we make some \textit{simplifying
assumptions}. This was done primarily to avoid adding unnecessary code and 
complexity to \afg design. 
 
One of these is handling the case where \acg{libc} address space changes during
execution. This is technically possible, but is rarely seen in production -
furthermore, it allows for performance optimisation opportunities as detailed in
Section~\ref{subsubsec:impl-find-site-opt}.

Care needs to be taken to ensure that this assumption doesn't introduce a
security risk during the implementation (see Section~\ref{subsubsec:impl-find-site-opt}). 
System calls made in the case where \ac{libc} has been changed should be
treated as disallowed system calls.

We also assume that the \texttt{\_\_code\_\_} section of the \ac{libc}
executable is mapped contiguously in memory. Again, this is
true (almost) without exception\footnote{Custom patches to the kernel could
violate this invariant} and allows \af to quickly determine if a given system
call instruction was made from within \ac{libc}.

It is also important to note that this assumption does not introduce a security
risk due to the way that system call site identification is implemented and shown in
Section \ref{subsubsec:impl-find-site-opt} \cite{glibc-dl-map-segments-h}.

The limitations of this design are linked to these assumptions. If \acg{libc}
address is not contiguous, then \af will not be able to find non-\ac{libc}
addresses correctly. This will result in system calls being marked as having 
\ac{libc} as a callsite, which will result in the system call filter being
tripped as discussed in Section \ref{subsubsec:err-handling}. 

The other obvious limitation of this design is that it only makes sense for
dynamically linked executables. Statically linked executables do not make use of
shared libraries and therefore making filters for each shared library does not
make sense.

With the relevant background fully explained and the requirements defined, we
can move on to presenting the design of \afss.~ 

\subsection{Architecture} \label{subsec:arch}

\begin{figure}[ht]
    \centering
    \includegraphics[width=0.8 \linewidth]{./diagrams/high-level-overview.drawio.pdf} 
    \caption{High level overview of \afg architecture}
    \label{fig:arch-overview}
\end{figure}

\af is comprised of a (kernel-space) backend and a userspace frontend.
\ac{bpf} maps and ringbuffers are used to allow the backend and frontend to
communicate. The frontend is responsible for spawning the filtered application,
handling configuration, and \textit{attaching} the \ac{bpf} program to it's
tracepoint (discussed further in Section \ref{sec:implementation}).

The backend of \af is made up of a single \ac{bpf} program and \ac{bpf}
maps/ringbuffers to communicate with userspace.
The program is attached to a \textit{raw tracepoint}, and runs every time
a system call is made - even ones not called by by the app being filtered.

\subsubsection{Determining Which system calls to
Filter}\label{subsec:design-fork-following}

This means \af needs a way to identify which system calls were made by the
protected app. \acp{pid} of filtered processes
need to be stored in \iac{bpf} map. Then, on every system call, we check if the
called process's \ac{pid} is in the map of filtered processes. If not, ignore
the system call. Otherwise, we continue with the filtering.

We also want to apply the filter to any child processes the
application might create - this is called \textit{fork following}. The reason for this is two-fold: a common workflow for
web servers (such as nginx) \cite{apache-prefork-2.4, nginx-inside-performance-scale-2015} is to fork on receiving a request; the second is
that if a \ac{ta} could just call fork() to remove the system call filter, our
solution would not be secure. Fork following is visualised in
Figure~\ref{fig:fork-follow-process-tree} with two process trees. With fork
following, each child process is protected by addrfilter. Without it, children
are left unprotected.

\begin{figure}[ht]
    \centering
    \includegraphics[width=0.8 \linewidth]{./diagrams/fork-following.drawio.pdf} 
    \caption{A diagram showing two different process trees: one with fork
    following (left) and one without fork following (right).}
    \label{fig:fork-follow-process-tree}
\end{figure}


To do this, we can also check if the parent process's \ac{pid} is in the follow
map. If it is, we add the calling \ac{pid} to the follow map, and continue with
the filtering. So, we only ignore system call if \textit{neither the current nor
parent \ac{pid} exists in the follow map}.

Having decided to filter a system call, we need to identify where in the process's
address space the system call was made. We might use the value of the \ac{pc} when
the system call was made, but this turns out to be unhelpful.
Almost all system calls are made via \ac{libc} in a dynamically linked 
application, and so the \ac{pc} almost always points to \ac{libc} instead of the
library that actually made the system call.

\subsubsection{Finding the system call Site}\label{subsubsec:find_syscall}

Therefore, \af must find the \textit{first non-\ac{libc} return pointer in the
userspace stack}, and treat this address as the true system call site. In other
words, we trace through the sequence of function calls that led to the system
calls and find the first call that wasn't made by libc.

For example consider a ``hello, world'' program in C (see Listing~\ref{lst:hello-world}). \texttt{printf()} is a 
function implemented in \ac{libc} which invokes the \texttt{write()} system call
behind the scenes, which in turn will call the \texttt{syscall} x86
instruction\footnote{This is a simplified stack trace: in \texttt{musl},
\texttt{write()} calls a wrapper function \texttt{system call\_cp\_c()}. However,
the idea still holds.}. This means the userspace stack may look something the stack
presented in Figure~\ref{fig:hello-world-stack}

\begin{figure}[h]
    \centering % Center the whole figure environment content

    % --- Subfigure for the Diagram (Left) ---
    \begin{subfigure}[b]{0.48\linewidth} % Adjust width as needed
        \centering % Center the image within the subfigure
        % Use the actual path to your diagram PDF
        \includegraphics[width=\linewidth]{./diagrams/hello-world-stack.drawio.pdf}
        \caption{High-level \afg core filtering logic.} % Sub-caption for diagram
        \label{subfig:stack-diagram} % Sub-label for diagram
    \end{subfigure}
    \hfill % Add horizontal space between subfigures (pushes them apart)
    % --- Subfigure for the Code Listing (Right) ---
    \begin{subfigure}[b]{0.48\linewidth} % Adjust width as needed
        \centering % Center the code block if needed (often takes container width)
        % Use minted for the code listing
        \begin{minted}[fontsize=\small, frame=lines, framesep=2mm, breaklines]{c}
#include <stdio.h>

int main() {

    // printf @ 0x0000F722AE12
    printf("Hello, World!\n");    

    return 0;
}
        \end{minted}
        \caption{Hello World example in C.} % Sub-caption for code
        \label{subfig:hello-world-code} % Sub-label for code
    \end{subfigure}

    % --- Overall Figure Caption and Label ---
    \caption{Diagram illustrating an example call stack for a Hello, World
    program with corresponding code example.}% Overall caption
    \label{fig:hello-world-stack} % Overall label

\end{figure}

The addresses shown in the diagram are \textit{return pointers}: these are the
memory address of the instructions which added a new frame to the stack. In this
context, it's helpful to think of return pointers as the \textit{address of a
function}. Note also that the top few stack frames all belong to \ac{libc}, with
the main binary a few frames deeper.

The idea is that here we want to classify this system call as having been made from
the \texttt{main} binary, not from \ac{libc}. We can do this by
\textit{unwinding the stack} until we find a return pointer which isn't within
\acg{libc} address space. This return pointer is then used as the system call
invocation site, as shown in Figure~\ref{fig:stack-unwinding}.

\begin{figure}[ht]
    \centering
    \includegraphics[width=0.95 \linewidth]{./diagrams/stack-unwinding.drawio.pdf} 
    \caption{A figure showing the stack unwinding process.}
    \label{fig:stack-unwinding}
\end{figure}

\subsubsection{Finding the Calling Shared Object File}\label{subsubsec:find_so}

Having found the memory address of the function which made the system call, we
can now figure out which shared library made the system call. Doing this is a
question of checking the process's \ac{vma} to find which memory region the
function belongs to. 

Each shared library exists in the \ac{vma} as a \textit{file backed memory region}.
In-kernel, the \ac{vma} is implemented as a \texttt{vma\_struct} struct with a
(indirect) reference to the name of it's backing file. Thus, finding which
shared library ``owns'' the system call site is a question of finding the
corresponding \texttt{vma\_struct} struct and reading the filename.
Alternatively, this information can be read from userspace via the
\texttt{/proc/PID/maps} pseudofile.

\begin{figure}[h]
    \centering
    \includegraphics[width=\linewidth]{./diagrams/core-filter-flowchart.drawio.pdf}
    \caption{A figure showing \afg core filtering logic at a high level.}
    \label{fig:core-filter-flowchart}
\end{figure}

\subsubsection{To Kill or not to Kill?}

Knowing which shared object file made the system call allows us to find the correct
system call whitelist and intervene if need be.

To do this, we keep a mapping from shared library filename to a set of allowed
system calls. We use the previously calculated filename as a key to this map to
retrieve some (pre-configured) whitelists. If the system call number is in the
whitelist, no action is taken and the \ac{bpf} tracepoint returns with code 0.

If the system call isn't on the whitelist, \af will intervene. The intervention
policy is user-configurable and has to be read from a config map. Userspace is
informed that a system call has tripped the filter as the offending \ac{pid} is
written to a ringbuffer. If the policy is set to kill the process (or all 
processes in the \ac{pid} filtering map), \af sends a kill signal to the 
offending \ac{pid}. 

When userspace reads \iac{pid} from the ringbuffer, it acts according to how it was
configured. A warning will be logged in warn mode, but in ``kill all'' mode, a
kill signal will be sent to each \ac{pid} in the filtering map. This has to be
done asynchronously (by userspace) as \ac{bpf} only allows you to send signals
to the calling process. The filtering process is summarised in pseudocode in
Listing~\ref{lst:syscall-filter} and visualised in 
Figure~\ref{fig:core-filter-flowchart}.

This design is minimal, modular, and easy to reason about. It can be achieved
with a single \ac{bpf} program running on the \texttt{raw\_tp/sys\_enter}
tracepoint with two core maps: one for storing the \acp{pid} of filtered apps
and the other for mapping shared library names to system call whitelists.

What's been laid out here is the interesting part of the application
- the core filtering logic. The frontend is much larger (in terms of LoC) than
the \ac{bpf} program, and also serves important functions in making the system
work.

\subsubsection{Configuring Whitelists and \ac{libc}}

The frontend is responsible for parsing the \af whitelists and loading them into
the whitelist map. We looked to build on existing standards for defining
system call whitelists but found none suitable for our use case. Seccomp filters,
for example, are defined as a \iac{bpf} program - this isn't user friendly and
doesn't allow for mapping shared libraries to system call filters. Therefore, we defined our
own standard: a very simple TOML file. An example is provided in
Listing~\ref{lst:toml-whitelist}.

The frontend is also responsible for supporting performance optimisations
discussed in Section \ref{sec:implementation}. One of these optimisations is
to keep track of \acp{libc} address space in a map, as we assume \acp{libc} won't
change. The frontend is responsible for finding the filtered app's \ac{libc}
address range and storing it in a map.

Ensuring that frontend functionality such as parsing whitelists is correct is
trivial with unit tests. Testing \ac{bpf} however is much more difficult.
Writing tests is technically possible but requires mocking a lot of key system
resources: crucially for us, the stack and the \ac{vma}. Having to mock core
functionality of a system often leads to brittle tests which aren't effective -
therefore, we chose a different method of validation and evaluation.

\subsection{Validation and Evaluation}

We plan to validate correctness using the \acg{ltp} ``syscall'' test
suite to ensure \af does not disrupt normal system call behaviour, supplemented
by manual verification of simpler programs. The validation process is presented
in Section~\ref{subsec:validation}.

The evaluation focuses on quantifying the security benefit
(Section~\ref{subsec:security-eval}) by comparing privilege reduction
against seccomp using a defined metric, alongside measuring runtime
performance overhead (Section~\ref{subsec:perf-eval}) across a suite of
benchmarks relative to seccomp and no filter to understand costs and
limitations. This requires the development of supporting tools for analysis
and whitelist generation, discussed in 
Section~\ref{subsubsec:additional-tooling}.

\subsection{Additional Tooling}\label{subsubsec:additional-tooling}

The first additional tool that we implemented and \textit{built in to \af} was
the whitelist generator. This whitelist generator works via dynamic analysis,
which is not a gold standard for whitelist generation. For this use case,
however, we think this acceptable - whitelist generation is orthogonal to our
work and is its own field of research. We have implemented a generator here
primarily to aid development and evaluation, but more work is needed to create a
production-ready generator based on static analysis.

We implement the whitelist generator using a lot of the same functionalities of
\af. The key difference is that after identifying the system call site, we write a
system call number to the syscall site's map (recall that at this stage \af would
check to see if the system call number was in the site's map and intervene if need
be). When the program finishes executing (or on Ctrl-C), the frontend reads the
contents of the bpf whitelist map and marshals the results to a TOML file.
The pseudocode is provided in Listing~\ref{lst:generator-pseudocode} and shows
that the generation code makes heavy use of \afg functionality.

We also need a tool that can launch an application with a seccomp filter enabled.
The tool takes as arguments an \af system call whitelist
and a path to an executable, parses the whitelist and generates a single
seccomp filter. This filter is made by taking the union of each shared 
library's allowed set of system calls present in the \af whitelist. The filter can
then be applied to a benchmark to provide comparison data. This tool will be
referred to as \texttt{af-seccomp}.

The final additional tool we need is an evaluation tool, \texttt{syso}.
\texttt{syso} takes in a binary as input and prints a comparison of the 
binary's privilege levels  when \af and seccomp are applied. It also saves
some raw data to disc for further post processing: a JSON mapping from
system call numbers to number of times executed, broken down by library. An
example of this is available in Listing~\ref{lst:syso-data-dump}.

This section looked to motivate the minimalist design philosophy, threat model,
and requirements for \af. We designed how \af should behave on each system call,
and discussed the need for kernel-space and user-space code. We also looked
forward to evaluating our solution and designed required additional tooling.

With these evaluation tools defined, the next step is to turn our design into a
working solution. In Section \ref{sec:implementation}, we show how the raw 
tracepoint attachment, BPF map structures, stack-unwinding logic and userspace 
frontend were implemented to realise the filtering, whitelist generation and 
seccomp-wrapper utilities described above.
